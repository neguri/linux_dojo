

## 프로세스 추적

### top 명령어
> top 명령어를 입력 후 , 옵션을 사용 할 수 있음  
spacebar : 화면을 즉시 업데이트 한다  
M : 현재 상주 메모리 사용량에 따라 분류한다  
T : 전체 누적 CPU 사용량에 따라 분류한다.  
P : 현재 CPU 사용량(default)에 따라 분류한다.  
u : 하나의 사용자 pid만 선택해서 보여준다.  
f : 다른 자료의 통계 자료가 나타나게 한다 (보고 싶은 항목을 선택 후 다시 화면으로 돌아가면 그 정보가 나오게 됨)  
? : 도움말을 보여준다.  
(비슷한 기능으로 atop 과 htop 이 있음)


### lsot
> 터미널에서 `lsof` 라고 입력해 보자. 정말 많은 출력이 나온다. (열려 있는 모든 파일(네트워크 리소스,동적 라이브러리, 파이프)을 보여준다.)
  COMMAND: 파일 디스크립터를 보유하는 프로세스 이름
  PID : 프로세스 ID  
  USER : 프로세스를 실행하는 사용자  
  FD: 파일의 목적 혹은 파일 기술자(?)
  TYPE: 파일 타입  
  DEVICE: 장치의 주 번호, 부 번호  
  SIZE: 파일의 크기  
  NODE: 파일의 아이노드 숫자  
  NAME: 파일 이름  
  
  
  > `lsof /usr` : usr에 열려 있는 파일만  
  `lsof -p pid` : 특정 pid만 보고자 할때  
  
  
 ### strace
 > 프로세스가 만든 모든 시스템 콜을 출력한다.  
 `strace cat /dev/null` 
 
 ### lstrace
 > 공유 라이브러리 콜을 추적한다. ltrace는 커널 레벨에서는 어떤 것도 추적하지 않는다. 
 
 
 ### thread
 
 > `ps m` 이렇게 하면 thread 정보까지 같이 나온다. pid 아래 몇개의 thread가 수행되고 있는지 보여준다.
  
### CPU 시간 측정
> `top -p pid` 로 특정 프로세스의 시간별 변화를 확인 할 수 있다. 
__/usr/bin/time ls` 를 하면 ls가 종료된 후 ls 가 얼마만큼의 cpu 시간을 사용하는지 확인 할 수 있다.  


### 프로세스 우선 순위 조정
> 커널은 특정 프로세스에 다른 프로세스보다 더 많은 CPU 시간을 부여하기 위해서 우선 순위를 관리한다. `ps -l` 로도 볼 수 있지만 `top` 명령이 더 보기 좋다.  
top 명령에서 'PR' 열에 커널의 현재 일정 우선 순위를 보여주게 되는데, 값이 크면 클 수록 커널은 CPU를 덜 할당해 준다. 그리고 프로그램이 실행 되는 동안 해당 프로세스가 소모하는 CPU시간에 따라
우선 순위는 자주 변경된다.   
NI(nice value)도 자주 나오는 값인데, 커널은 우선순위에 이 NI를 추가해서 해당 프로세스가 보유할 다음 시간대를 결정 한다. 기본 NI 값은 0 이다. 그리고 `renice 20 pid` 와 같이 변경 할 수 있고, NI를 음수로 변경할 수도 있지만 좋은 방법은 아니다. 

### load average
> `uptime` 명령을 통해서 load average를 확인할 수 있다. 값은 %를 의미하므로 값이 1 이면 100% 인데, CPU의 모든 자원을 사용하고 있다는 뜻이다. 그런데 코어가 여러개이면 코어 갯수로 나눠야 한다. 코어가 2개인데, load average가 1 이면 CPU 하나만큼만 사용하고 있다는 의미이다.  

### vmstat
> 커널이 페이지를 얼마나 자주 교환하는지, CPU가 얼마나 바쁘게 활동 중인지, I/O가 어떻게 활용되는지 보여준다.(
__vmstat 2` 라고 하면 2초 간격으로 통계를 보여주게 됨)  

### iostat
> vmstats는 일반적인 I/O 통계를 보여주게 되는데, vmstat -d 로 하면 너무 많은 정보를 보여준다. 그래서 `iostat` 를 사용해서 I/O 상태만 보여주는 `iostat` 를 사용한다.  
> vmstat 와 비슷하게 시간 간격을 부여해서 모니터링 할 수 있으며, `iostat -p ALL` 명령을 통해 전체 파티션 모두를 확인 할 수 있다. 


### pidstat

> top나 iotop은 특정 프로세스를 모니터링하게 되는데, `pidstat` 는 이미 제거된 프로세스 정보도 볼 수 있다. 


## 장치

### /dev
> `ls -l` 을 해서 보면, `brw`, `crw`, `prw`, `srw` 라고 나오게 되는데 
> * 블록 장치: sda1 과 같이 디스크 장치이며, 블록 단위의 데이터로 분리된다. 블록 장치의 전체 크기는 고정되어 있고 색인으로 정하기 쉽기 때문에, 프로세스는 커널의 도움을 받아서 장치안의 어떤 블록이든 임의 접근 가능하다
> * 문자 장치: 데이터 스트림과 함께 작동된다. 문자 장치에서 문자를 읽을 수 있거나 문자 장치로 문자를 기록할 수 있다. 문자 장치는 블록 장치와 다르게 크기를 가지고 있지 않다. 읽거나 쓸 때는 커널이 장치상에서 읽고 쓰는 작업을 수행한다. 문자 장치간 상호 작동이 이뤄지는 동안 커널은 데이터 장치나 프로세스에 전달한 후 데이터를 백업하고 재검토하지 않는다. 
> * 파이프 장치: `named pipe` (한 프로세스의 출력을 다른 프로세스의 입력으로 연결해주는 파이프) 와 비슷하다. 커널 드라이버 대신 I/O 스트림의 다른쪽에 또 다른 프로세스를 가지고 있다. 
> * 소켓 장치: `/dev` 디렉토리 외부에서도 볼 수 있는데 유닉스 도메인 소켓에 해당한다.

### dd
> `dd if=/dev/zero of=new_file bs=1024 count=1` 라는 명령이 있다고 하자.
> * if=file : 입력 파일. 디폴트는 표준 입력.
> * of=file : 출력 파일. 디폴트는 표준 출력.
> * bs=size : 블록 사이즈. dd 는 한번에 많은 바이트의 데이터를 읽고 작성하게 된다. 커다란 데이터 덩어리를 줄이려면 각각 512 바이트, 1024 바이트를 의미하는 b와 k를 사용할 수 있다. 그래서 bs=1024는 bs=1k로 읽을 수 있다.
> * ibs=size, obs=size : 입출력에 같은 크기의 블록을 사용할 수 있지만 서로 다르게 사용할 수도 있다.
> * count=num : 복사되는 총 블록의 수, 커다른 파일로 작업하거나 /dev/zero처럼 끝없이 스트림으로 이어지는 데이터를 제공하는 장치와 함께 작업을 하는 경우, 특정 위치에서 dd를 멈추게 한다. 그렇지 않으면 디스크 공간이나 cpu 모두를 낭비하게 된다. 
> * skip : 입력 파일이나 스트림에서 첫번째 num 블록을 건너뛰고 이들을 출력하지 않는다.


### /dev/sd*
> 스카시(small computer system interface, SCSI) 디스크를 나타낸다. `lsscsi` 를 통해서 장치의 정보를 확인 할 수 있다. 

### 터미널
> `pseudo terminal` 장치는 실제 터미널의 I/O 기능을 이해하는 모조 터미널인데, 실제 하드웨어의 일부분과 소통하는것이 아니라 커널이 셸 터미널 윈도우 처럼 소프트웨어 일부분에 I/O 인터페이스를 제시한다.   
> 흔히 사용하는 터미널은 `/dev/tty1` 과 `/dev/pts/0` 이다. `/dev/pts`는 전용 파일 시스템이다. 

### /dev/ttyS*
> 오래된 RS-232 타입이나 그와 유사한 직렬 포트는 좀 특별한 터미널 장치라고 할 수 있다. 윈도우즈에서 COM1 이라고 알려진 포트는 `/dev/ttyS0` 이며, USB 장치는 `/dev/ttyUSB` 처럼 표시된다. 

### /dev/lp0, /dev/lp1
> 병렬 포트임. 즉 LPT1:, LPT2: 가 된다.


## udev
### udevd 운영과 설정
> 1. 커널은 `udevd` 로 내부 네트워크 링크를 통해서 `uevent`라고 불리는 알림 이벤트를 전송한다.
> 2. `udevd`는 `uevent` 안의 모든 속성들을 로딩한다.
> 3. `udevd`는 그 규칙들을 분석하고 조취를 취하거나 그 규칙들을 기반으로 더 많은 속성들을 설정한다.  
> `/lib/udev/rules.d` 와 `/etc/udev/rules.d` 경로에 규칙 파일들이 존재한다.  
> 자세한 것은 `udev(7)` 매뉴얼 페이지를 참조하자
### udevadm
> `udevd`의 관리자 프로그램이다. `udevd` 규칙들을 리로딩하고 이벤트가 동작하도록 할 수 있다.  
> `udevadm info --query==all --name=/dev/sda` 와 같은 명령어로 속성을 확인할 수 있다.

### 장치 모니터링
> `udevadm monitor` 명령을 통해 메시지를 확인할 수 있다. 만약 서브 시스템에 따른 이벤트를 걸러내려면 다음과 같이 하면 된다.  `udevadm monitor --kernel --subsystem-match=scsi` 라고 하면 SCSI 시스템에서 일어나는 변화만 볼 수 있다. 
