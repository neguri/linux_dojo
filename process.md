

## 프로세스 추적

### top 명령어
> top 명령어를 입력 후 , 옵션을 사용 할 수 있음  
spacebar : 화면을 즉시 업데이트 한다  
M : 현재 상주 메모리 사용량에 따라 분류한다  
T : 전체 누적 CPU 사용량에 따라 분류한다.  
P : 현재 CPU 사용량(default)에 따라 분류한다.  
u : 하나의 사용자 pid만 선택해서 보여준다.  
f : 다른 자료의 통계 자료가 나타나게 한다 (보고 싶은 항목을 선택 후 다시 화면으로 돌아가면 그 정보가 나오게 됨)  
? : 도움말을 보여준다.  
(비슷한 기능으로 atop 과 htop 이 있음)


### lsot
> 터미널에서 `lsof` 라고 입력해 보자. 정말 많은 출력이 나온다. (열려 있는 모든 파일(네트워크 리소스,동적 라이브러리, 파이프)을 보여준다.)
  COMMAND: 파일 디스크립터를 보유하는 프로세스 이름
  PID : 프로세스 ID  
  USER : 프로세스를 실행하는 사용자  
  FD: 파일의 목적 혹은 파일 기술자(?)
  TYPE: 파일 타입  
  DEVICE: 장치의 주 번호, 부 번호  
  SIZE: 파일의 크기  
  NODE: 파일의 아이노드 숫자  
  NAME: 파일 이름  
  
  
  > `lsof /usr` : usr에 열려 있는 파일만  
  `lsof -p pid` : 특정 pid만 보고자 할때  
  
  
 ### strace
 > 프로세스가 만든 모든 시스템 콜을 출력한다.  
 `strace cat /dev/null` 
 
 ### lstrace
 > 공유 라이브러리 콜을 추적한다. ltrace는 커널 레벨에서는 어떤 것도 추적하지 않는다. 
 
 
 ### thread
 
 > `ps m` 이렇게 하면 thread 정보까지 같이 나온다. pid 아래 몇개의 thread가 수행되고 있는지 보여준다.
  
### CPU 시간 측정
> `top -p pid` 로 특정 프로세스의 시간별 변화를 확인 할 수 있다. 
__/usr/bin/time ls` 를 하면 ls가 종료된 후 ls 가 얼마만큼의 cpu 시간을 사용하는지 확인 할 수 있다.  


### 프로세스 우선 순위 조정
> 커널은 특정 프로세스에 다른 프로세스보다 더 많은 CPU 시간을 부여하기 위해서 우선 순위를 관리한다. `ps -l` 로도 볼 수 있지만 `top` 명령이 더 보기 좋다.  
top 명령에서 'PR' 열에 커널의 현재 일정 우선 순위를 보여주게 되는데, 값이 크면 클 수록 커널은 CPU를 덜 할당해 준다. 그리고 프로그램이 실행 되는 동안 해당 프로세스가 소모하는 CPU시간에 따라
우선 순위는 자주 변경된다.   
NI(nice value)도 자주 나오는 값인데, 커널은 우선순위에 이 NI를 추가해서 해당 프로세스가 보유할 다음 시간대를 결정 한다. 기본 NI 값은 0 이다. 그리고 `renice 20 pid` 와 같이 변경 할 수 있고, NI를 음수로 변경할 수도 있지만 좋은 방법은 아니다. 

### load average
> `uptime` 명령을 통해서 load average를 확인할 수 있다. 값은 %를 의미하므로 값이 1 이면 100% 인데, CPU의 모든 자원을 사용하고 있다는 뜻이다. 그런데 코어가 여러개이면 코어 갯수로 나눠야 한다. 코어가 2개인데, load average가 1 이면 CPU 하나만큼만 사용하고 있다는 의미이다.  

### vmstat
> 커널이 페이지를 얼마나 자주 교환하는지, CPU가 얼마나 바쁘게 활동 중인지, I/O가 어떻게 활용되는지 보여준다.(
__vmstat 2` 라고 하면 2초 간격으로 통계를 보여주게 됨)  

### iostat
> vmstats는 일반적인 I/O 통계를 보여주게 되는데, vmstat -d 로 하면 너무 많은 정보를 보여준다. 그래서 `iostat` 를 사용해서 I/O 상태만 보여주는 `iostat` 를 사용한다.  
> vmstat 와 비슷하게 시간 간격을 부여해서 모니터링 할 수 있으며, `iostat -p ALL` 명령을 통해 전체 파티션 모두를 확인 할 수 있다. 


### pidstat

> top나 iotop은 특정 프로세스를 모니터링하게 되는데, `pidstat` 는 이미 제거된 프로세스 정보도 볼 수 있다. 


## 장치

### /dev
> `ls -l` 을 해서 보면, `brw`, `crw`, `prw`, `srw` 라고 나오게 되는데 
> * 블록 장치: sda1 과 같이 디스크 장치이며, 블록 단위의 데이터로 분리된다. 블록 장치의 전체 크기는 고정되어 있고 색인으로 정하기 쉽기 때문에, 프로세스는 커널의 도움을 받아서 장치안의 어떤 블록이든 임의 접근 가능하다
> * 문자 장치: 데이터 스트림과 함께 작동된다. 문자 장치에서 문자를 읽을 수 있거나 문자 장치로 문자를 기록할 수 있다. 문자 장치는 블록 장치와 다르게 크기를 가지고 있지 않다. 읽거나 쓸 때는 커널이 장치상에서 읽고 쓰는 작업을 수행한다. 문자 장치간 상호 작동이 이뤄지는 동안 커널은 데이터 장치나 프로세스에 전달한 후 데이터를 백업하고 재검토하지 않는다. 
> * 파이프 장치: `named pipe` (한 프로세스의 출력을 다른 프로세스의 입력으로 연결해주는 파이프) 와 비슷하다. 커널 드라이버 대신 I/O 스트림의 다른쪽에 또 다른 프로세스를 가지고 있다. 
> * 소켓 장치: `/dev` 디렉토리 외부에서도 볼 수 있는데 유닉스 도메인 소켓에 해당한다.

### dd
> `dd if=/dev/zero of=new_file bs=1024 count=1` 라는 명령이 있다고 하자.
> * if=file : 입력 파일. 디폴트는 표준 입력.
> * of=file : 출력 파일. 디폴트는 표준 출력.
> * bs=size : 블록 사이즈. dd 는 한번에 많은 바이트의 데이터를 읽고 작성하게 된다. 커다란 데이터 덩어리를 줄이려면 각각 512 바이트, 1024 바이트를 의미하는 b와 k를 사용할 수 있다. 그래서 bs=1024는 bs=1k로 읽을 수 있다.
> * ibs=size, obs=size : 입출력에 같은 크기의 블록을 사용할 수 있지만 서로 다르게 사용할 수도 있다.
> * count=num : 복사되는 총 블록의 수, 커다른 파일로 작업하거나 /dev/zero처럼 끝없이 스트림으로 이어지는 데이터를 제공하는 장치와 함께 작업을 하는 경우, 특정 위치에서 dd를 멈추게 한다. 그렇지 않으면 디스크 공간이나 cpu 모두를 낭비하게 된다. 
> * skip : 입력 파일이나 스트림에서 첫번째 num 블록을 건너뛰고 이들을 출력하지 않는다.


### /dev/sd*
> 스카시(small computer system interface, SCSI) 디스크를 나타낸다. `lsscsi` 를 통해서 장치의 정보를 확인 할 수 있다. 

### 터미널
> `pseudo terminal` 장치는 실제 터미널의 I/O 기능을 이해하는 모조 터미널인데, 실제 하드웨어의 일부분과 소통하는것이 아니라 커널이 셸 터미널 윈도우 처럼 소프트웨어 일부분에 I/O 인터페이스를 제시한다.   
> 흔히 사용하는 터미널은 `/dev/tty1` 과 `/dev/pts/0` 이다. `/dev/pts`는 전용 파일 시스템이다. 

### /dev/ttyS*
> 오래된 RS-232 타입이나 그와 유사한 직렬 포트는 좀 특별한 터미널 장치라고 할 수 있다. 윈도우즈에서 COM1 이라고 알려진 포트는 `/dev/ttyS0` 이며, USB 장치는 `/dev/ttyUSB` 처럼 표시된다. 

### /dev/lp0, /dev/lp1
> 병렬 포트임. 즉 LPT1:, LPT2: 가 된다.


## udev
### udevd 운영과 설정
> 1. 커널은 `udevd` 로 내부 네트워크 링크를 통해서 `uevent`라고 불리는 알림 이벤트를 전송한다.
> 2. `udevd`는 `uevent` 안의 모든 속성들을 로딩한다.
> 3. `udevd`는 그 규칙들을 분석하고 조취를 취하거나 그 규칙들을 기반으로 더 많은 속성들을 설정한다.  
> `/lib/udev/rules.d` 와 `/etc/udev/rules.d` 경로에 규칙 파일들이 존재한다.  
> 자세한 것은 `udev(7)` 매뉴얼 페이지를 참조하자
### udevadm
> `udevd`의 관리자 프로그램이다. `udevd` 규칙들을 리로딩하고 이벤트가 동작하도록 할 수 있다.  
> `udevadm info --query==all --name=/dev/sda` 와 같은 명령어로 속성을 확인할 수 있다.

### 장치 모니터링
> `udevadm monitor` 명령을 통해 메시지를 확인할 수 있다. 만약 서브 시스템에 따른 이벤트를 걸러내려면 다음과 같이 하면 된다.  `udevadm monitor --kernel --subsystem-match=scsi` 라고 하면 SCSI 시스템에서 일어나는 변화만 볼 수 있다. 


## 사용자 공간 시동 방법

### init 소개
> 사용자 공간은 (대략) 아래와 같은 순서로 시작된다. 
> 1. init
> 2. udevd 와 syslogd 같은 필수적 저-수준 서비스
> 3. 네트워크 환경 설정
> 4. 중간-수준과 고-수준 서비스 (크론, 출력등)
> 5. 로그인 프롬픝, GUI, 기타 고-수준 응용 프로그램


> 리눅스 배포판에서 init은 세가지 구현 사항이 있다.
> 1. `System V init` : 전통적인 순차적 init (system five 라고 읽자)
> 2. `systemd` : 대부분은 리눅스 시스템에서 사용하고 있다.
> 3. `Upstart` : 우분투 설치할 때 사용하는 init (이지만 systemd로 옮겨가려고 한다.)

> 오래된 init 시스템의 경우 한번에 하나씩 순차적으로 수행하기 때문에 종속성 문제를 해결하기 쉽지만 성능은 좋지 않은 편이다. 대신 `systemd` 나 `upstart` 는 여러 서비스가 동시적으로 시작되도록 하여 속도를 높히고 있다.  `systemd`는 하위 호환성을 위해서 `runlevel` 을 지원한다.  
> `who -r` 이란 명령어를 통해서 현재 runlevel과 runlevel 이 설정된 시간을 확인 할 수 있다.  
> (`/etc/inittab` 파일이 있다면 System V init을 사용하고 있는 것)

### systemd
> systemd 가 부트 타임에 어떤 동작을 하는지 아래 처럼 확인 할 수 있다.
> 1. systemd가 설정을 로딩한다.
> 2. systemd가 부트 목표를 알아낸다. 보통 default.target 이라는 이름이다.
> 3. systemd가 기본 부트 목표의 모든 종속 요소들, 그 종속 요소들의 종속 요소들을 파악한다.
> 4. systemd는 종속 요소들과 부트 목표를 활성화 시킨다.
> 5. 부팅 후에 systemd는 (uvents와 같은) 시스템 이벤트들에 대응하고 추가 요소들을 활성화 시킨다.

> systemd는 단지 프로세스들과 서비스만 가동하는 것이 아니라 파일 시스템을 마운트하고 네트워크 소켓을 모니터링하고 타이머와 그 외 많은 것들을 실행 시킬 수 있다. 이런 기능의 각 형태를 `unit type`라고 부르고 각 구체적 기능을 `unit` 이라고 부른다.

> 1. service units : 유닉스 시스템의 전통적인 서비스 데몬을 제어
> 2. mount units : 시스템으로의 파일 시스템 연결을 제어한다.
> 3. target units : 다른 유닛을 제어한다. 일반적으로 유닛을 그룹으로 나눈ㄴ 방법을 사용하여 제어한다.

#### systemd 종속성

> `Requires` : 엄격한 종속성, Requires 종속 유닛과 함께 어떤 유닛을 활성화 할때 systemd는 종속 유닛을 활성화 하려고 시도한다. 종속 유닛이 실패히게 되면 systemd 는 해당 unit을 비활성화 한다.  
> `Wants`: 오직 활성화를 위한 종속성. 그 종속성 유닛이 실패하더라도 상관하지 않는다.  
> `Requisite`: 이미 활성화 된 유닛이며, 그 종속 유닛이 활성화 되어 있지 않으면 해당 유닛을 비활성화 한다.  
> `Conflicts`: 부정적 종속성, Conflict 종속성을 가진 유닛을 활성화 시카면 systemd 는 그 종속 유닛이 활성화된 상태라면 자동으로 그 해당 유닛을 비활성화 시킨다.  

#### 순서
> `Before` : 현재 유닛은 열거된 유닛 이전에 활성화 되어야 한다. Before=bar.target 이 foo.target 에 있다고 하면 bar.target 보다 foo.target이 먼저 실행된다.   
> `After` : 현재 유닛은 열거된 유닛 이후에 활성화 된다.   

#### 조건부 종속성
> `ConditionPathExists=p` 만약 (파일) 경로 p 가 시스템에 존재하면 true.  
> `ConditionPathIsDirectory=p` 만약 p 가 디렉토리이면 true.  
> `ConditionFileNotempty=p` 만약 p 가 파일이고 크기가 0 이 아니면 true.

#### systemd 설정
> systemd 설정 파일은 시스템의 여러곳에 분포하고 있다. 그래서 `systemctl -p UnitPath show` 를 통해서 경로를 확인할 수 있다.   
> 보통 두개의 경로에 파일들이 들어 있는데 __시스템 유닛 디렉터리 (/usr/lib/systemd/system)__ 와 __시스템 설정 디렉터리 (/etc/systemd/system)__ 에 들어가 있다. 일반적으로 시스템 유닛 디렉터리는 변경하지 않고 시스템 설정 디렉터리에서 지역적으로 변경하도록 한다. 

#### systemd 프로세스 추적과 동기화
> systemd는 `cgroup` 를 사용하는데  
> `Type=simple` 서비스 프로세스가 포크되지 않는다.    
> `Type=forking` 서비스가 포크되고 systemd는 처음 서비스 프로세스가 종료될 것으로 기대한다.   
> `Type=notify` 서비스가 준비되는 `sd_notify()` 함술ㄹ 통해서 systemd에게 통지한다 .  
> `Type=dbus` 서비스가 준비되면 D-bus(Desktop Bus)에 자신을 등록한다.
> `Type=oneshot` 프로세스가 멈출때, 그 프로세스가 완전히 종룧ㄴ다. `ReaminAfterExit=yes`를 통해서 프로세스가 종료되더라도 systemd가 여전히 서비스가 활성화 된것으로 간주한다.


### 사용자 관리 파일
#### /etc/passwd 파일
> 평문 파일인 /etc/passwd 는 사용자명을 ID와 연결한다. 
> 대략 아래와 같은데, 각 라인은 한명의 사용자에 대해서 7개의 필드가 나온다.
```bash
jaehoc@pgsql>  cat /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
jaehoc:x:1000:1000:jaehoc,,,:/home/jaehoc:/usr/bin/zsh
```
> 1. 사용자 명
> 2. 사용자의 암호화된 비밀 번호. passwd 파일에 저장하지 않고 shadow 파일에 저장한다. 보통 사용자들은 shadow 파일을 읽을 권한 이 없다. `x`란 의미는 암호화된 비밀번호가 shadow 파일에 저장되어 있다는 뜻이며 `*` 표시는 사용자가 로그인 할수 없다는 으미이다. `::`처럼 필드가 비어 있으면 로그인 비밀 번호가 필요하지 않다는 의미 이다.
> 3. 사용자 ID (UID)
> 4. 그룹 ID (GID). `/etc/group` 파일에서 번호가 붙은 항목들 중 하나여야 한다. 그룹은 파일의 접근 권한을 결정하고 그 외 역할은 거의 없다.
> 5. 사용자의 실제 이름
> 6. 사용자의 홈 디렉토리
> 7. 사용자의 셸

> 사용자를 추가하고자 할때 `/etc/passwd` 를 직접 편집하면 된다. 하지만 직접 편집하는 것 보다는 `adduser` 와 `userdel`을 사용하는 것이 좋다.

#### Groups 활용
> 유닉스의 groups는 특정 사용자들하고만 파일을 공유하고 그 외 모든 사람들의 접근은 허용하지 않도록 한다. `/etc/group` 파일에서 그룹 ID를 정의한다. 
 ``` bash
systemd-coredump:x:999:
rdma:x:133:
postgres:x:134:
tomcat:x:1001:
docker:x:998:jaehoc
```

위와 같은 정보들을 볼수 있는데
> 1. 그룹명
> 2. 그룹 비밀 번호
> 3. 그룹 ID : GID 로서 /etc/passwd 안에 들어간다
> 4. 해당 그룹에 속한 사용자들에 대한 선택 목록

자신이 속한 그룹이 어디인지 확인하고자 한다면
`groups` 명령을 통해서 사용자가 어느 그룹에 속해 있는지 확인 가능하다.


### getty
> getty 는 터미널에 연결되어 로그인 프롬프트를 나타내는 프로그램이다. getty는 시스템에 가상 터미널에 로그인 할때만 사용하는 것이라 복잡하지 않다. 
